{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Autogen documentation","text":"<p>Autogen is an automatic expression generator using Wick\u2019s theorem for quantum chemistry derivations.</p> <p>This <code>docs/</code> folder is the main documentation. The root README is intentionally short and points here.</p>"},{"location":"#start-here","title":"Start here","text":"<ul> <li>Overview: overview.md</li> <li>Install: installation.md</li> <li>Usage (examples): usage.md</li> <li>Concepts/definitions: concepts.md</li> <li>API guide: api.md</li> <li>Input/output: io.md</li> <li>Testing: testing.md</li> <li>Performance: performance.md</li> <li>Work log: work_log.md</li> </ul>"},{"location":"#imports","title":"Imports","text":"<p>All code should import from the canonical package paths:</p> <ul> <li><code>autogen.library</code></li> <li><code>autogen.main_tools</code></li> <li><code>autogen.pkg</code></li> </ul>"},{"location":"#repository-layout","title":"Repository layout","text":"<ul> <li><code>src/autogen/</code> \u2013 the installable Python package</li> <li><code>tests/</code> \u2013 pytest suite</li> <li><code>docs/</code> \u2013 documentation (this folder)</li> </ul>"},{"location":"api/","title":"API guide","text":"<p>This is a pragmatic guide to the functions most users call directly.</p>"},{"location":"api/#commutators","title":"Commutators","text":""},{"location":"api/#autogenmain_toolscommutatorcomm","title":"<code>autogen.main_tools.commutator.comm</code>","text":"<pre><code>from autogen.main_tools.commutator import comm\n\nterms = comm(['V2'], ['T2'], last=1)\n</code></pre> <ul> <li>Inputs are commonly operator-label lists like <code>['V2']</code>, <code>['T1']</code>, etc.</li> <li><code>a</code> and <code>b</code> may also be lists of term objects (to build nested expressions).</li> <li>Returns a <code>list</code> of term objects.</li> </ul>"},{"location":"api/#nested-commutators","title":"Nested commutators","text":"<p>Compute innermost-first:</p> <pre><code>from autogen.main_tools.commutator import comm\n\ninner = comm(['V2'], ['T1'], last=0)\nouter = comm(inner, ['D1'], last=1)\n</code></pre>"},{"location":"api/#products","title":"Products","text":""},{"location":"api/#autogenmain_toolsproductprod","title":"<code>autogen.main_tools.product.prod</code>","text":"<pre><code>from autogen.main_tools.product import prod\n\nterms = prod(['X1'], ['V2'], last=1)\n</code></pre>"},{"location":"api/#composing-products-and-commutators","title":"Composing products and commutators","text":"<p>You can combine these building blocks to form expressions like $X_1 [V_2, T_1]$:</p> <pre><code>from autogen.main_tools.commutator import comm\nfrom autogen.main_tools.product import prod\n\nvt1 = comm(['V2'], ['T1'], last=0)\nx1_vt1 = prod(['X1'], vt1, last=1)\n</code></pre>"},{"location":"api/#filtering-fully-contracted-terms","title":"Filtering fully-contracted terms","text":""},{"location":"api/#autogenlibraryfull_confull_terms","title":"<code>autogen.library.full_con.full_terms</code>","text":"<pre><code>from autogen.library.full_con import full_terms\n\ncontracted_only = full_terms(terms)\n</code></pre> <p>Note: some workflows use the <code>last</code> parameter as a \u201cthis is the outermost call\u201d flag. When in doubt, use <code>last=1</code> only at the outermost level of an expression you intend to print.</p>"},{"location":"api/#converting-indices-pqr","title":"Converting indices (<code>p,q,r</code>)","text":""},{"location":"api/#autogenlibraryconvert_pqrconvert_pqr","title":"<code>autogen.library.convert_pqr.convert_pqr</code>","text":"<pre><code>from autogen.library.convert_pqr import convert_pqr\n\nconverted = convert_pqr(terms)\n</code></pre>"},{"location":"api/#printing-latex-output","title":"Printing LaTeX output","text":""},{"location":"api/#autogenlibraryprint_termsprint_terms","title":"<code>autogen.library.print_terms.print_terms</code>","text":"<pre><code>from autogen.library.print_terms import print_terms\n\nprint_terms(terms, 'latex_output.txt')\n</code></pre>"},{"location":"api/#driver-style-generation","title":"Driver-style generation","text":""},{"location":"api/#autogenmain_toolsdriv3driver","title":"<code>autogen.main_tools.driv3.driver</code>","text":"<pre><code>from autogen.main_tools.driv3 import driver\n\n# Example: build and contract a list of labeled operators\nterms = driver(1.0, ['X1', 'V2', 'T1'])\n</code></pre> <p>Note: <code>driver</code> prints a lot of diagnostic output; it is closer to a workflow helper than a \u201cpure\u201d library function.</p> <p>Next: see usage.md for end-to-end examples.</p>"},{"location":"concepts/","title":"Concepts and definitions","text":"<p>This project uses short operator labels to represent common second-quantized building blocks.</p>"},{"location":"concepts/#operators","title":"Operators","text":"Label Meaning Notes <code>X1</code> Project onto single excitation on the left Used for amplitude/projection expressions <code>X2</code> Project onto double excitation on the left Used for amplitude/projection expressions <code>T1</code> Single excitation cluster operator $t_i^a a_a^{\\dagger} a_i$ <code>T2</code> Double excitation cluster operator $t_{ij}^{ab} a_a^{\\dagger} a_b^{\\dagger} a_j a_i$ <code>D1</code> Single de-excitation operator $d_i^a a_i^{\\dagger} a_a$ <code>D2</code> Double de-excitation operator $d_{ij}^{ab} a_i^{\\dagger} a_j^{\\dagger} a_b a_a$ <code>V2</code> Two-body fluctuation operator $\\tfrac{1}{4}\\langle pq|rs\\rangle a_p^{\\dagger} a_q^{\\dagger} a_s a_r$ <code>F1</code> One-body (Fock-like) operator $f_{pq} a_p^{\\dagger} a_q$"},{"location":"concepts/#terms","title":"Terms","text":"<p>A \u201cterm\u201d is the internal object representing:</p> <ul> <li>A specific contraction pattern (operator string with contracted indices)</li> <li>Its prefactor and sign</li> <li>Summation indices and coefficient structure</li> </ul> <p>Most top-level APIs return lists of terms.</p>"},{"location":"concepts/#commutators-and-products","title":"Commutators and products","text":"<ul> <li><code>comm(A, B, last)</code> computes a commutator (or nested commutator pieces).</li> <li><code>prod(A, B, last)</code> computes an operator product.</li> </ul> <p>The <code>last</code> flag is used by some workflows to decide when to apply \u201cfully contracted\u201d filtering.</p> <p>Next: see api.md for the concrete functions and their signatures.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#quick-install-pypi","title":"Quick install (PyPI)","text":"<p>To install the latest release directly from PyPI:</p> <pre><code>pip install autogen-wick\n</code></pre> <p>This will install the package and all dependencies. You can then use it in Python:</p> <pre><code>import autogen\n</code></pre> <p>Optional: install PySCF if you want to run the generated integral/einsum scripts:</p> <pre><code>pip install pyscf\n</code></pre> <p>Or with conda:</p> <pre><code>conda install -c conda-forge pyscf\n</code></pre>"},{"location":"installation/#recommended-conda-environment","title":"Recommended: conda environment","text":"<p>From the repo root:</p> <pre><code>conda env create -f environment.yml\nconda activate autogen\n</code></pre> <p>To update an existing environment:</p> <pre><code>conda env update -f environment.yml --prune\nconda activate autogen\n</code></pre> <p>This environment installs the project in editable mode (<code>-e .</code>), so imports work from anywhere.</p>"},{"location":"installation/#build-artifacts-sdist-wheel","title":"Build artifacts (sdist + wheel)","text":"<pre><code>conda run -n autogen python -m build\n</code></pre> <p>Outputs go into <code>dist/</code>.</p> <p>Next: see testing.md and usage.md.</p>"},{"location":"io/","title":"Input and output","text":"<p>Autogen is a library. Most \u201cinputs\u201d are Python scripts that call the APIs and then print terms to a file.</p>"},{"location":"io/#output-file","title":"Output file","text":"<p>Many workflows print LaTeX-friendly output to a text file (commonly <code>latex_output.txt</code>).</p> <ul> <li>The package does not require a specific output file name, but many scripts default to <code>latex_output.txt</code>.</li> <li>The debug workflow defaults to <code>latex_output.txt</code> as well.</li> </ul>"},{"location":"io/#printing-terms","title":"Printing terms","text":"<pre><code>from autogen.library.print_terms import print_terms\n\nprint_terms(terms, 'latex_output.txt')\n</code></pre>"},{"location":"io/#debug-workflow","title":"Debug workflow","text":"<pre><code>python debug.py\n</code></pre> <p>This calls <code>autogen.debug.run_debug()</code> and writes to <code>latex_output.txt</code> by default.</p>"},{"location":"io/#example-scripts","title":"Example scripts","text":"<p>You may see historical scripts named <code>input.py</code> under various folders (e.g. older experiments under <code>backup/</code>). Treat those as runnable examples rather than a single canonical input format.</p>"},{"location":"io/#method-specs-and-generated-code-layout","title":"Method specs and generated code layout","text":"<ul> <li>Method input specs live under <code>method_inputs/&lt;method&gt;/</code> (for example, <code>method_inputs/ccsd/ccsd_spec.py</code>).</li> <li>Generated code is written under <code>generated_code/methods/&lt;method&gt;/</code> and includes <code>__init__.py</code> files so it can be imported as a package.</li> <li>Slow integration test molecule fixtures live under <code>tests/molecules/</code>.</li> </ul> <p>Next: see usage.md for example pipelines.</p>"},{"location":"overview/","title":"Overview","text":"<p>Autogen is an automatic expression generator for second-quantized many-body expressions using Wick\u2019s theorem.</p> <p>It is designed to generate algebraic expressions in the same \u201cdiagram-style\u201d symbolic form commonly used in electronic structure theory derivations (e.g., coupled cluster and unitary coupled cluster).</p>"},{"location":"overview/#what-it-produces","title":"What it produces","text":"<ul> <li>Lists of symbolic \u201cterms\u201d representing operator strings, contractions, delta factors, and prefactors.</li> <li>LaTeX-friendly output via the printing utilities.</li> </ul>"},{"location":"overview/#key-features","title":"Key features","text":"<ul> <li>String-based operator specification (e.g., <code>['V2']</code>, <code>['T1']</code>) with internal expansion to operator objects.</li> <li>Recursive handling of nested commutators (innermost-first).</li> <li>Support for de-excitation operators (e.g., <code>D1</code>, <code>D2</code>) to enable UCC-style algebra.</li> </ul> <p>In particular, features like de-excitation support and nested commutators (e.g. <code>[[V2, T1], D1]</code>) make Autogen suitable for unitary coupled cluster (UCC) style derivations.</p>"},{"location":"overview/#package-layout","title":"Package layout","text":"<ul> <li><code>autogen.library</code> \u2013 core term/operator structures and utilities</li> <li><code>autogen.main_tools</code> \u2013 commutator/product/driver orchestration</li> <li><code>autogen.pkg</code> \u2013 EWT/GWT utilities</li> </ul> <p>Next: see usage.md for runnable examples.</p>"},{"location":"performance/","title":"Performance notes","text":"<p>This page summarizes the performance-related changes and how to control them.</p>"},{"location":"performance/#compare-reduction","title":"Compare reduction","text":"<p>The term reduction logic has a fast path that groups terms by a canonical hash and only falls back to full structural comparison when needed.</p> <ul> <li><code>AUTOGEN_COMPARE_MODE=fast</code> (default) uses the fast compare path.</li> <li><code>AUTOGEN_COMPARE_MODE=full</code> forces the original compare path.</li> <li><code>AUTOGEN_COMPARE_MODE=check</code> runs both and warns on mismatches.</li> </ul> <p>The reducer now uses a two-stage bucketization: 1) coarse key (term signature + index incidence + structural key), then 2) matrix signature inside buckets with &gt;1 term. This shrinks compare-heavy buckets before invoking full comparisons.</p> <p>Level-5 compare now caches the coefficient index graph for each juggled term to avoid rebuilding <code>ind</code> objects across repeated compares. This keeps the arrowwork path fast without changing comparison semantics.</p> <ul> <li><code>AUTOGEN_COMPARE_LEVEL5=cached</code> (default) uses the cached arrowwork path.</li> <li><code>AUTOGEN_COMPARE_LEVEL5=matrix</code> attempts a matrix-based match (experimental).</li> </ul>"},{"location":"performance/#contraction-caching","title":"Contraction caching","text":"<p>Two caching layers reduce repeated contraction work:</p> <ul> <li>Prefix caching in <code>driv3</code> (useful for commutator/product flows).</li> <li>Disable with <code>AUTOGEN_CACHE=0</code>.</li> <li>LRU caching for multi-operator contractions in <code>multi_cont</code>.</li> <li>Disable with <code>AUTOGEN_MULTI_CONT_CACHE=0</code>.</li> <li>Resize with <code>AUTOGEN_MULTI_CONT_CACHE_SIZE=256</code> (default 256).</li> </ul> <p><code>make_c</code> also memoizes contraction matchings by operator pattern so repeated calls across different index names can reuse the same matching lists.</p> <ul> <li>Disable with <code>AUTOGEN_MATCHING_CACHE=0</code>.</li> <li>Resize with <code>AUTOGEN_MATCHING_CACHE_SIZE=128</code> (default 128).</li> </ul> <p>Cached objects share underlying operator structures. Treat contraction objects as immutable. If you need to mutate them, deep copy first.</p>"},{"location":"performance/#copy-avoidance-in-term-objects","title":"Copy avoidance in term objects","text":"<p><code>class_term.term</code> supports <code>copy_inputs=False</code> to avoid deep copies of lists that are already unique to the term. When used, callers must treat inputs as immutable for the lifetime of the term.</p>"},{"location":"performance/#contraction-emission","title":"Contraction emission","text":"<p>The contraction formatter operates on lists and slices rather than deques to reduce per-term overhead when building and emitting contracted terms.</p>"},{"location":"performance/#numba-contraction-enumeration","title":"Numba contraction enumeration","text":"<p><code>make_c</code> can use a Numba-accelerated matcher to enumerate contraction pairs.</p> <ul> <li>Enable with <code>AUTOGEN_NUMBA=1</code>.</li> <li>Requires <code>numba</code> to be installed.</li> <li>If Numba is unavailable or fails at runtime, it falls back to the original   Python recursion.</li> <li><code>AUTOGEN_NUMBA_CANDS_CACHE=0</code> disables caching the typed candidate list.</li> <li><code>AUTOGEN_NUMBA_CANDS_CACHE_SIZE=64</code> sets the typed candidate cache size.</li> </ul> <p>Note: the order of emitted terms can differ when Numba is enabled, but the resulting set of terms and constants should be equivalent.</p>"},{"location":"performance/#ccsd-intermediates","title":"CCSD intermediates","text":"<p><code>scripts/gen_einsum.py CCSD_AMPLITUDE --intermediates</code> emits reusable pair intermediates and groups repeated <code>einsum</code> calls.</p> <ul> <li><code>AUTOGEN_INTERMEDIATE_MIN=3</code> sets the minimum reuse count to materialize.</li> <li><code>AUTOGEN_INTERMEDIATE_MAX=80</code> caps the number of intermediates (0 = no cap).</li> </ul>"},{"location":"performance/#parity-helpers","title":"Parity helpers","text":"<p>The parity computation caches the index map for <code>full_pos</code> to avoid rebuilding the same dictionary for each term. This is transparent to callers.</p>"},{"location":"performance/#benchmarking-and-checks","title":"Benchmarking and checks","text":"<p>Compare-heavy benchmarks:</p> <pre><code>python scripts/bench_compare.py --repeat 3 --warmup 1\n</code></pre> <p>Quick correctness check with both compare paths:</p> <pre><code>AUTOGEN_COMPARE_MODE=check python debug.py\n</code></pre> <p>When debugging mismatches, disable caches and Numba:</p> <pre><code>AUTOGEN_COMPARE_MODE=full AUTOGEN_CACHE=0 AUTOGEN_MULTI_CONT_CACHE=0 AUTOGEN_NUMBA=0 python debug.py\n</code></pre>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#fast-tests-default","title":"Fast tests (default)","text":"<p>Runs the quick unit + smoke tests:</p> <ul> <li><code>conda run -n autogen pytest -q</code></li> </ul>"},{"location":"testing/#slow-tests","title":"Slow tests","text":"<p>PySCF-backed CCSD checks (now parameterized over several molecules) are marked slow and skipped by default. Enable them with:</p> <ul> <li><code>RUN_SLOW=1 conda run -n autogen pytest -q</code></li> </ul> <p>Or just that subset:</p> <ul> <li><code>RUN_SLOW=1 conda run -n autogen pytest -q -k ccsd</code></li> <li><code>RUN_SLOW=1 conda run -n autogen pytest -q -k eom_ccsd</code></li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#create-environment","title":"Create environment","text":"<p>From repo root:</p> <ul> <li><code>conda env create -f environment.yml</code> (first time)</li> <li><code>conda env update -f environment.yml --prune</code> (update)</li> <li><code>conda activate autogen</code></li> </ul>"},{"location":"usage/#typical-operations","title":"Typical operations","text":""},{"location":"usage/#commutator","title":"Commutator","text":"<pre><code>from autogen.main_tools.commutator import comm\n\nterms = comm(['V2'], ['T2'], 1)\n</code></pre>"},{"location":"usage/#filtering-fully-contracted-terms","title":"Filtering fully contracted terms","text":"<pre><code>from autogen.library.full_con import full_terms\n\ncontracted = full_terms(terms)\n</code></pre>"},{"location":"usage/#debug-script","title":"Debug script","text":"<ul> <li><code>python debug.py</code></li> </ul> <p>This uses the implementation in <code>autogen.debug</code> and writes to <code>latex_output.txt</code> by default.</p>"},{"location":"usage/#performance-compare-modes","title":"Performance / compare modes","text":"<p>When reducing equivalent terms, the compare layer supports an opt-in mode switch:</p> <ul> <li><code>AUTOGEN_COMPARE_MODE=fast</code> (default) uses faster comparison paths when safe.</li> <li><code>AUTOGEN_COMPARE_MODE=full</code> forces the original compare logic.</li> <li><code>AUTOGEN_COMPARE_MODE=check</code> runs both and warns on any mismatch.</li> <li><code>AUTOGEN_QUIET=1</code> suppresses verbose term/contraction prints.</li> <li><code>AUTOGEN_CACHE=0</code> disables contraction prefix caching (debug only).</li> <li><code>AUTOGEN_MULTI_CONT_CACHE=0</code> disables multi-operator contraction caching.</li> <li><code>AUTOGEN_MULTI_CONT_CACHE_SIZE=256</code> sets the multi-operator cache size (LRU).</li> <li><code>AUTOGEN_SPIN_SUMMED=1</code> emits spin-summed residuals (recommended for RHF).</li> <li><code>AUTOGEN_SPIN_SUMMED_MODE=spinorb</code> switches to the legacy spin-orbital wrapper path.</li> <li><code>AUTOGEN_INTERMEDIATE_MIN=3</code> sets the minimum reuse count for CCSD intermediates.</li> <li><code>AUTOGEN_INTERMEDIATE_MAX=80</code> caps the number of CCSD intermediates (0 = no cap).</li> <li><code>AUTOGEN_MATCHING_CACHE=0</code> disables pattern-level contraction match caching in <code>make_c</code>.</li> <li><code>AUTOGEN_MATCHING_CACHE_SIZE=128</code> sets the pattern cache size (LRU).</li> <li><code>AUTOGEN_NUMBA=1</code> enables Numba-based contraction enumeration (optional).</li> <li><code>AUTOGEN_NUMBA_CANDS_CACHE=0</code> disables caching of typed candidate lists for Numba.</li> <li><code>AUTOGEN_NUMBA_CANDS_CACHE_SIZE=64</code> sets the typed-candidate cache size (LRU).</li> </ul> <p>Example:</p> <pre><code>AUTOGEN_COMPARE_MODE=check python debug.py\n</code></pre> <p>Benchmark the compare-heavy workflows:</p> <pre><code>python scripts/bench_compare.py --repeat 3 --warmup 1\n</code></pre>"},{"location":"usage/#generated-einsum-scripts","title":"Generated einsum scripts","text":"<p>The generated einsum examples (e.g., under <code>generated_code/</code>) rely on PySCF for integrals. Install it before running those scripts:</p> <pre><code>pip install pyscf\n</code></pre> <p>Or with conda:</p> <pre><code>conda install -c conda-forge pyscf\n</code></pre> <p>Generate einsum scripts:</p> <pre><code>python scripts/gen_einsum.py V2 T1 T1\npython scripts/gen_einsum.py V2 T2\npython scripts/gen_einsum.py F1 T1\npython scripts/gen_einsum.py CCSD_ENERGY\npython scripts/gen_einsum.py CCSD_AMPLITUDE\npython scripts/gen_einsum.py CCSD_AMPLITUDE --full --quiet\npython scripts/gen_einsum.py CCSD_AMPLITUDE --intermediates --quiet\npython scripts/gen_einsum.py --spec path/to/spec.py --full --quiet\npython scripts/gen_einsum.py --spec path/to/spec.py --intermediates --quiet\npython scripts/gen_einsum.py --spec method_inputs/ccsd/ccsd_spec.py --intermediates --quiet\npython scripts/gen_einsum.py --spec method_inputs/eom_ccsd/ee_eom_ccsd_spec.py --intermediates --quiet\n</code></pre> <p>Notes: - The CCSD energy script uses PySCF CCSD amplitudes and Fock matrix in the MO basis. - The default molecule for generated scripts is H2O/6-31G in <code>generated_code/pyscf_integrals.py</code>. - The iterative CCSD solver is generated under <code>generated_code/methods/ccsd/ccsd_amplitude/</code>. - Use <code>--full</code> to emit explicit residual terms and <code>--intermediates</code> to emit reusable intermediates. - Use <code>--spec</code> to drive custom term lists; the output defaults to <code>generated_code/methods/&lt;spec-stem&gt;/residuals.py</code>. - Method input specs live under <code>method_inputs/&lt;method&gt;/</code>. - For RHF spin-summed CCSD, generate with <code>AUTOGEN_SPIN_SUMMED=1</code> (optionally keep <code>SPIN_ADAPTED=True</code> in the spec). - Spin-summed residuals are generated directly from the Wicks terms. Set <code>AUTOGEN_SPIN_SUMMED_MODE=spinorb</code> only if you need the spin-orbital wrapper mapping. - EE-EOM-CCSD uses the same spin-summed RHF pathway and emits <code>eom_solver.py</code> plus <code>eom_pyscf_test.py</code> under <code>generated_code/methods/eom_ccsd/</code>. - The EOM spec uses the spin-orbital singlet wrapper when <code>SPIN_ADAPTED=True</code>. For EE-EOM-CCSD, the generator will coerce <code>AUTOGEN_SPIN_SUMMED_MODE=direct</code> to the singlet wrapper to keep results consistent with PySCF. In spin-orbital mode, the generator emits <code>residuals_spinorb.py</code> plus a <code>residuals.py</code> wrapper that maps singlet amplitudes in/out. - The EE-EOM-CCSD spec defaults to <code>EOM_BCH=True</code>, which builds H\u0305 via nested commutators (exact for CCSD, fewer terms than direct T-expansion).</p>"},{"location":"work_log/","title":"Work log","text":"<p>This file summarizes the recent performance and correctness work on Autogen.</p>"},{"location":"work_log/#changes-implemented","title":"Changes implemented","text":"<ul> <li>Compare path: added fast structural keys, two-stage reduction, lazy matrix build,   and a lightweight <code>_CoeffTerm</code> to avoid deep copies in <code>src/autogen/library/compare.py</code>   and <code>src/autogen/library/compare_utils.py</code>.</li> <li>Compare level-5: cache coefficient index graphs on juggled terms to avoid   rebuilding <code>ind</code> objects; add a guarded permutation check for short operator   names and an optional <code>AUTOGEN_COMPARE_LEVEL5=matrix</code> mode.</li> <li>Generated code layout: method outputs now live under   <code>generated_code/methods/&lt;method&gt;</code>, with input specs in   <code>method_inputs/&lt;method&gt;</code> and molecule fixtures in <code>tests/molecules</code>.</li> <li>EE-EOM-CCSD: added R1/R2 operator support, a spin-summed EOM spec, a   Davidson solver emitter, and PySCF-based regression tests.</li> <li>EE-EOM-CCSD generation: switched to exact BCH nested-commutator expansion   (H\u0305) plus hash-first term reduction to cut contraction and compare cost.</li> <li>EE-EOM-CCSD spin adaptation: default to the spin-orbital singlet wrapper for   <code>SPIN_ADAPTED</code> specs and map R1/R2 via PySCF singlet transforms to match   <code>eom_rccsd.EOMEESinglet</code>.</li> <li>EE-EOM-CCSD direct mode: treat <code>AUTOGEN_SPIN_SUMMED_MODE=direct</code> as an alias   to the singlet wrapper to keep results consistent with PySCF.</li> <li>EOM index handling: tokenized indexed labels (e.g., <code>i1</code>, <code>a1</code>) during   canonicalization and intermediate selection, and made <code>view_tensor</code>/output   labeling robust to numeric suffixes.</li> <li>Special conditions: avoid exiting on non-indexed operator names and default   to position 1 instead.</li> <li>Contraction engine: rewrote <code>make_c</code> pairing enumeration to avoid deep copies,   added pattern-level matching caches, and added a pure-Python DFS fallback that   can be cached and reused across index renamings.</li> <li>Multi-operator contraction: added LRU caching in <code>src/autogen/main_tools/multi_cont.py</code>.</li> <li>Parity: cached index maps in <code>src/autogen/pkg/parity.py</code>.</li> <li>Term objects: added <code>copy_inputs=False</code> for <code>class_term.term</code> and used it in   <code>src/autogen/library/change_terms.py</code>.</li> <li>Spin-summed option: gated spin-loop factors and cross-spin 1/2 factors behind   <code>AUTOGEN_SPIN_SUMMED</code> in <code>src/autogen/pkg/fix_uv.py</code> (default on).</li> <li>Spin-summed CCSD residuals: generate directly from Wicks terms when   <code>AUTOGEN_SPIN_SUMMED=1</code>. The spin-orbital wrapper path is kept as an optional   fallback via <code>AUTOGEN_SPIN_SUMMED_MODE=spinorb</code>.</li> <li>CCSD solver energy: updated the generated solver to use the PySCF RHF   CCSD energy formula with raw integrals (<code>g_raw</code>) for numerical agreement.</li> <li>Numba support: optional contraction enumeration via <code>AUTOGEN_NUMBA=1</code>.</li> <li>Fixed warnings and correctness: indentation in <code>src/autogen/library/class_term.py</code>,   raw-string fixes in <code>src/autogen/pkg/fix_uv.py</code> and <code>src/autogen/pkg/fewt.py</code>,   and <code>pytest</code>/<code>debug.py</code> path fixes for local imports.</li> </ul>"},{"location":"work_log/#new-or-updated-scripts","title":"New or updated scripts","text":"<ul> <li><code>scripts/time_ccsd_terms.py</code>: time each CCSD amplitude term and print slowest terms.</li> <li><code>scripts/time_ccsd_full.py</code>: run full CCSD amplitude and print elapsed time.</li> <li><code>scripts/profile_term_breakdown.py</code>: measure <code>make_op</code>, <code>multi_cont</code>, <code>full_con</code>,   <code>change_terms</code>, <code>compare+reduce</code>.</li> <li><code>scripts/profile_compare_hotspots.py</code>: report per-function compare timings.</li> <li><code>tests/test_ccsd_pyscf.py</code>: slow PySCF-backed verification of energy and residuals.</li> <li><code>tests/test_eom_ccsd_pyscf.py</code>: slow PySCF-backed EE-EOM-CCSD checks.</li> </ul>"},{"location":"work_log/#environment-variables","title":"Environment variables","text":"<ul> <li><code>AUTOGEN_COMPARE_MODE=fast|full|check</code></li> <li><code>AUTOGEN_COMPARE_LEVEL5=cached|matrix</code></li> <li><code>AUTOGEN_QUIET=1</code></li> <li><code>AUTOGEN_CACHE=0</code></li> <li><code>AUTOGEN_MULTI_CONT_CACHE=0</code>, <code>AUTOGEN_MULTI_CONT_CACHE_SIZE=...</code></li> <li><code>AUTOGEN_MATCHING_CACHE=0</code>, <code>AUTOGEN_MATCHING_CACHE_SIZE=...</code></li> <li><code>AUTOGEN_NUMBA=1</code></li> <li><code>AUTOGEN_NUMBA_CANDS_CACHE=0</code>, <code>AUTOGEN_NUMBA_CANDS_CACHE_SIZE=...</code></li> <li><code>AUTOGEN_SPIN_SUMMED=1</code> (default on)</li> <li><code>AUTOGEN_SPIN_SUMMED_MODE=spinorb</code> (legacy wrapper path)</li> <li><code>SPIN_ADAPTED=True</code> in a spec for RHF spin-summed CCSD residual generation</li> </ul> <p>For details, see <code>docs/usage.md</code> and <code>docs/performance.md</code>.</p>"},{"location":"work_log/#performance-snapshots","title":"Performance snapshots","text":"<p>Benchmarked on the slowest CCSD term <code>['X2','V2','T2','T21']</code> using a custom breakdown:</p> <ul> <li>Before cached level-5: <code>multi_cont</code> ~4.30s, <code>compare+reduce</code> ~21.16s.</li> <li>After cached level-5: <code>multi_cont</code> ~4.68s, <code>compare+reduce</code> ~11.35s.</li> </ul> <p>Per-term CCSD timing (<code>scripts/time_ccsd_terms.py</code>): - Total 33.883s \u2192 27.295s. - Slowest term 18.651s \u2192 11.805s.</p> <p>Full CCSD amplitude timing (<code>scripts/time_ccsd_full.py</code>): - 34.199s \u2192 26.582s.</p>"},{"location":"work_log/#intermediate-residuals","title":"Intermediate residuals","text":"<ul> <li>Added <code>--intermediates</code> mode in <code>scripts/gen_einsum.py</code> to emit reusable pair   intermediates and grouped <code>einsum</code> calls with <code>optimize=True</code>.</li> <li>Generated CCSD residuals now expose <code>AUTOGEN_INTERMEDIATES</code> and   <code>compute_r1_r2</code> for shared intermediate reuse across R1/R2.</li> <li>Added <code>--spec</code> support to generate residual code from a user-provided Python   spec (custom term lists with optional intermediate emission).</li> </ul>"},{"location":"work_log/#tests","title":"Tests","text":"<ul> <li><code>pytest -q</code> (1 skipped)</li> <li><code>RUN_SLOW=1 pytest -q -k pyscf</code> for PySCF numeric checks</li> <li><code>RUN_SLOW=1 pytest -q -k eom_ccsd</code> for EE-EOM-CCSD checks</li> </ul>"},{"location":"work_log/#numba-install-note-macos","title":"Numba install note (macOS)","text":"<p>Pip builds can fail due to missing LLVM. Prefer conda-forge:</p> <pre><code>conda activate autogen\npython -m pip uninstall -y numba llvmlite\nconda install -c conda-forge numba llvmlite\n</code></pre>"}]}